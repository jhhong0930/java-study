# 추상클래스, 인터페이스

# 추상클래스

**추상메서드를 포함하고 있다**는 것을 제외하고는 일반클래스와 전혀 다르지 않음. 추상클래스에도 생성자가 있으며, 멤버변수와 메서드도 가질 수 있음

# 추상메서드

선언부만 작성하고 구현부는 작성하지 않은 것. 보통 주석을 덧붙여 어떤 기능을 수행할 목적으로 작성됐는지 알려주고, 상속받은 클래스가 실제 내용을 구현하도록 함.

```java
abstract class Player{

	/*주석을 통해 어떤 기능을 수행할 목적으로 작서했는지 설명*/
	abstract void stop();

}

```

abstract의 존재이유? 자손클래스에서 추상메서드를 반드시 구현하도록 강요하기 위해서이다.

# 탬플릿 메서드

탬플릿 메서드 안에 스태틱 메서드들이 있는거임. 정확히 어떻게 실행될진 모르겠지만,  상속받은 클래스가 그 추상메소드들을 구현하면 탬플릿메서드가 정한 순서대로 실행되는것임!!!

구현의 순서가 다 정해져있는거임. final로 된 함수는 오버라이드 못해(재정의 못해).

즉 탬플릿메서드는 하위클래스에서 변환할수 없기에 final이란 키워드를 씀. 

장점:  시나리오를 구현하는데에 있어서 새로운 추상클래스를 추가 하고싶을때 편함

![Untitled](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3,%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%2055ef373fb7fd487abe0305fc674214f6/Untitled.png)

![Untitled](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3,%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%2055ef373fb7fd487abe0305fc674214f6/Untitled%201.png)

---

나중에 Car클래스를 상속하는 클래스는 abstract메서드들만 구현한다면 run()함수는 그냥 쓰기만 하면됨. 어떻게 abstract메서드를 구현하냐에 따라 run()함수는 내용은 달라지지만 실행하는 동작순서는 동일하게 유지된다.

---

---

# 인터페이스

일종의 추상클래스이지만, 일반적인 메서드 또는 멤버변수를 가질 수 없다. 즉, 구현된 것은 아무것도 없다는 것.

모든 멤버변수는 public static final이어야 하며, 생략가능

모든 메서드는 public abstract 이어야 하며, 생략가능

```java
interface 인터페이스이름{
	public static final 타입이름 = 값;   //이렇게만 가능함. 단 생략가능(컴파일러가 자동으로 추가)
	int CLOVER = 1; //생략시 컴파일러가 추가-> public static final int CLOVER = 1;

	public abstract String getCarNumber();
	String getCard(); //생략시 컴파일러가 추가-> public abstract String getCard();
}
```

# 인터페이스의 다형성 활용

```java
class IcecreamMachine{
	public static Icecream getIcecream(String type){
		if(type.equals("choco"){
			return new ChocoIcecream();
		}else if(type.equals("banila")){
			return new BanilaIcecream();
		}
	}
}

class ChocoIcecream implements Icecream(){
	...
}
class BanilaIcecream implements Icecream(){
	...
}
```

Icecream 인터페이스를 사용하는 곳에서는 그저 "choco"를 먹을지  "banila"를 먹을지만 써주면 받는 객체가 달라진다. 또한, 그 외 다른 맛(딸기, 밀크)을 추가하고자 한다면 구현부에서만 추가를 하면 되고 이를 사용하는 아래의 코드에서는 바뀌는 것 없이 getIcecream()안에 맛을 써주기만 하면 되는 편리함이 생긴다.

```java
Icecream icecream = IcecreamMachine.getIcecream("choco");
```

# 인터페이스의 장점

1. 개발시간 단축
    
    이미 작성된 인터페이스를 이용하여 프로그램 작성하면 된다. 한 팀은 인터페이스를 구현하는 클래스 작성, 다른 한팀은 인터페이스의 메서드를 사용하여 활용하는 코드작성하면 구현하는 클래스 완성될때까지 기다리지 않고도 동시에 개발진행 가능
    
2. 표준화 가능
    
    기본 틀을 제공하므로.
    
3. 서로 관계없는 클래스들을 관계맺어줄 수 있다
    
    하나의 인터페이스 안에다가 넣어서 구현.
    
4. 독립적인 프로그래밍 가능
    
    클래스의 선언과 구현을 분리하기에 실제구현에 독립적인 프로그램 작성가능. 클래스와 클래스간의 직접적인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면, 한 클래스의 변경이 다른클래스에 영향을 미치지 않게 되는 프로그래밍이 가능
    
- 스타크래프트 예시
    
    # 스타크래프트 예시
    
    ## 공통점 부여하기
    
    ![Untitled](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3,%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%2055ef373fb7fd487abe0305fc674214f6/Untitled%202.png)
    
    ![Untitled](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3,%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%2055ef373fb7fd487abe0305fc674214f6/Untitled%203.png)
    
    ![Untitled](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3,%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%2055ef373fb7fd487abe0305fc674214f6/Untitled%204.png)
    
    ![Untitled](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3,%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%2055ef373fb7fd487abe0305fc674214f6/Untitled%205.png)
    
    우리 scv라는 클래스에 수리기능을 구현하고자 하는데, 우리 일꾼 scv는 탱크와 드랍십은 고칠 수 있지만, 마린은 고칠 수 없다. 
    
    방법1:
    
    ```java
    class SCV extends GroundUnit{
    	....
    	void repair(Tank t){
    	}
    	void repair(Dropship d){
    	}
    	..이렇게 유닛하나하나 해야하나?
    
    }
    ```
    
    방법2:
    
    ```java
    class SCV extends GroundUnit {
    	....
    	void repair(GroundUnit gu){
    	}
    	void repair(AirUnit au){
    	}
    	..근데 이러면 Marine은? 못고치는데ㅠ
    
    }
    ```
    
    즉 현재 유닛들의 상속관계에서는 repair를 적용시킬거냐 안할거냐에 대한 공통점이 없다. 이때 인터페이스를 사용하면 기존의 상속관계는 유지하되, repair에 관한 공통점을 부여할 수 있다!!!
    
    해결:
    
    ```java
    interface Repairable{}
    
    class SCV extends GroundUnit implements Repairable{
    	...
    }
    class Tank extends GroundUnit implements Repairable{
    	...
    }
    class Dropship extends GroundUnit implements Repairable{
    	...
    }
    class Marine extends GroundUnit{
    	...//얘만 Repairable 구현 못했다!
    }
    ```
    
    위처럼 하고 이제 SCV클래스에서 repair을 다시 정의해보자
    
    ```java
    class SCV extends GroundUnit {
    	....
    	void repair(Repairable r){
    			// 이제 repair()의 매개변수로는 Marine이 못들어온다
    	}	
    
    }
    ```
    
    ## 위와 유사하지만 다른목적의 예- User, Provider 분리
    
    테란은 몇몇 건물을 띄울 수 있음.
    
    ![Untitled](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3,%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%2055ef373fb7fd487abe0305fc674214f6/Untitled%206.png)
    
    ![Untitled](%E1%84%8E%E1%85%AE%E1%84%89%E1%85%A1%E1%86%BC%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3,%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%2055ef373fb7fd487abe0305fc674214f6/Untitled%207.png)
    
    위 상속도처럼 Building을 동일하게 상속받지만 어떤 건물은 못 띄우고, 어떤 건물은 띄울 수 있음. 어떻게 처리해야 할까?
    
    순서 1. 먼저 껍데기만 있는 인터페이스 만들고
    
    ```java
    interface Liftable{
    	void liftOff();//띄우기
    	void land();//착륙시키기
    }
    ```
    
    순서 2. 인터페이스의 기능을 구현하는 클래스 작성
    
    ```java
    class LiftableImpl implements Liftable{
    	public void liftOff(){
    		...//날도록 하는 복잡한 내용
    	}
    	public void land(){
    		...//착륙하도록 하는 복잡한 내용
    	}
    }
    ```
    
    순서 3. 이제 띄울 수 있는 건물들은 LIftable을 구현하도록 하고, 기능을 넣으면 된다
    
    ```java
    class Factory extends Building implements Liftable{
    	**LiftableImple l = new LiftableImple(); //이게 키포인트**
    
    	void liftOff(){ l.liftOff();}
    	void land(){ l.land();}
    }
    ```
    
    이케 Imple이라는 인터페이스에서 정의한 메서드의 기능들을 구현하는 클래스를 만들어 놓으면, 이를 사용하는 클래스에서는 일일이 인터페이스의 메서드를 구현할 필요 없이 그냥 갖다쓰면 되는 엄청난 편리한 점이 생긴다.
    
- 인터페이스의 특징 두가지
    - 클래스를 사용하는 쪽과 제공하는 쪽이 있으며
    - 메서드를 사용하는(호출) 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 되며 내용은 몰라도 된다.