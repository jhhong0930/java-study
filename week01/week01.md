# 클래스, 메서드, 변수, 객체, 생성자

클래스 : JAVA에서 모든 코드는 클래스 안에서 정의되며, 그안에 정보와 기능을 정의할 때 사용하는 변수와 메서드를 가집니다.

메서드 : 작업을 수행하는 코드를 하나로 묶어 놓은 것으로 객체의 기능을 정의하고 있습니다.

변수 : 데이터를 저장하기 위한 메모리 공간의 이름입니다.

객체 : 클래스의 인스턴스를 객체라고 하며 new()라는 키워드를 통해 생성이되며 생성이 되는 순간 메모리를 할당받습니다.

생성자 : 객체가 생성될 때 호출되는 메서드로, 반드시 하나 이상의 생성자가 존재해야하며, 작성하지 않으면 컴파일러가 자동으로 기본생성자를 추가해줍니다. 주로 객체의 변수를 초기화할때 사용합니다.

# 클래스와 객체

클래스는 객체가 갖는 속성(정보), 기능들을 정의 해놓은 틀이다.

변수를 활용하여 속성을 정의하고 메서드로 기능을 정의한다.

new 키워드를 사용하여 실제 메모리에 객체를 생성하고 생성자를 호출한다.

**형식** : 클래스이름 변수이름 = new 클래스이름();

# 선언 위치에 따른 변수의 종류

- **멤버변수 : 생성 시점에 타입별로 초기화가 이루어진다.**
    - **클래스 변수(Static)** : JVM이 실행될 때 클래스와 함께 공유 메모리에 저장된다. 따라서 같은 클래스에서 생성된 모든 객체들은 클래스 변수를 공유한다. ex) 환율 처럼 모든 객체에 똑같이 반영 되어야 하는 값들은 클래스 변수로 설정하면 좋다.

      접근방법은 객체와 무관하기 때문에 클래스 이름으로 접근해야한다.

    - **인스턴스 변수** : 객체가 생성될 때 함께 힙 영역에 저장된다.

      객체마다 생성되기 때문에 객체별로 고유한 상태를 가질 수 있다.

      접근방법은 객체의 이름을 통해서 접근하면 된다.

      객체가 없어져서 가비지 컬렉션이 발생하면 메모리에서 삭제된다.



- **로컬변수 : 자동으로 초기화 되지 않기 때문에 사용 전 초기화가 필요하다.**

  메서드 내부 변수, 메서드 파라미터 변수등이 여기에 속한다. 메서드 호출시 스택영역에 저장된다.

  해당영역({})이 끝나면 자동으로 삭제된다.

- 변수의 초기화 방법

  명시적 초기화, 초기화 블록, 생성자

    - 명시적 초기화 : int i = 3;
    - 초기화 블록 { 인스턴스 변수 초기화 }, static { 클래스 변수  초기화 }

- 기본형 변수와 참조형 변수
    - 기본형 : byte, short, int, long, float, double, char, boolean
    - 참조형 : 기본형 외의 모든 변수

  변수의 값이 파라미터로 전달될 때 기존의 값이 복사되어 전달이 된다.

  기본형은 변수에 저장된 것이 값 그 자체이다.

  참조형은 실제 객체가 아니라 객체에 대한 참조값이다. 따라서 참조값을 전달 받은 곳에서 그 참조값을 통해 객체의 내용을 수정하면 원래있던 객체의 내용이 변경될 수 있다.

    ```java
    public class Hanghae{
    		int num = 10;
    		static void change1(int n){
    					n += 100;
    					System.out.println("ch1 : " + n);
    		}
    		static void change2(Hanghae h){
    					h.num += 100;
    					System.out.println("ch2 : " + h.num);
    		}

    public static void main(String[] args){
    			Hanghae hm = new Hanghae();
    			hm.num = 5;
    			System.out.println("ch1 전 : " + hm.num);
    			// 5
    			Change1(hm.num);
    			System.out.println("ch1 후 : " + hm.num);
    			// 5
          Change2(hm);
    			System.out.println("ch2 후 : " + hm.num);
    			// 105
    	}
    }
    ```

# 메서드

**형태** : 접근제한자 리턴타입 메서드이름(타입 변수명,...){ code }

리턴타입이 있다면 return으로 반드시 같은 타입으로 반환해야 한다. 대신 묵시적 형변환은 가능하다. 묵시적 형변환이란 리턴 타입이 int일 때 int보다 작은 byte, short 등을 반환할 수 있음을 뜻한다.

반환값이 필요없을 때는 리턴타입에 void를 사용하면 된다.

()안에 들어가는 변수 즉, 파라미터는 선언된 파라미터와 개수가 동일해야 하고 타입은 묵시적 형변환이 가능하다.

cf) 가변인자 : 예를 들어 파라미터에 올 값들의 개수가 다양한 경우 사용된다. 방법은 파라미터 타입과 변수명 사이에 ...으로 표시한다. (int...params)

params는 내부적으로 배열로 되어있기 때문에 값을 받아 사용할 때 배열로 처리해야 한다.

**메서드 호출 방법**

- static 메서드 : 클래스와 함께 바로 공유메모리에 생성되어 있음으로 클래스 이름을 사용해서 바로 호출할 수 있다.
- 인스턴스 메서드 : 반드시 객체를 생성한 후 객체를 통해서 접근이 가능하다. 같은 클래스 내에서 호출하는 경우는 객체 없이 바로 호출가능하다.

**메서드 호출 스택**

- 메서드는 호출되는 과정에서 메모리 상자를 하나씩 할당 받는다. 이는 스택영역으로 LIFO구조다. 이때 파라미터 변수등의 로컬변수들이 저장되며 외부에서는 접근할 수 없고 내부에서만 접근할 수 있다.

  **메서드 동작 예시)** A메서드 호출 시 스택메모리 영역에 A상자 생성, 이때 A메서드에서 B메서드를 호출 시 B를 실행하기 위해 A상자위에 새롭게 생성된 B상자를 쌓는다. 이때 밑에 깔린 A상자는 정지상태가 되고 위에 있는 B상자만 동작한다. B메서드가 종료되면 B상자는 제거되고 밑에 있던 A상자가 최상위 메서드가 되면서 다시 동작한다.

# 메모리 관리

JAVA는 OS에 구애받지 않고 어디서든 실행된다. 그것을 가능하게 해주는 것이 **JVM**이다. **JVM**은 또한 가비지 컬렉터를 사용한 메모리 관리로 C처럼 따로 메모리를 관리하지 않아도 자동으로 관리한다.

또 다른 특징은 다른 하드웨어들과는 다르게 레지스터 기반이 아니라 스택기반으로 동작한다.

**JVM**은 크게 Garbage Collector, Execution Engine, Class Loader, Runtime Data Area 4가지 구조로 나뉘어진다.

이때 클래스, 인터페이스, 메서드, 필드, Static 변수 등의 바이트코드는 **Runtime Data Area** 의 **Method area**에 저장된다. 의미상 공유 메모리 영역이라고도 불린다. 모든 스레드가 공유하는 영역이다.

new 키워드로 생성된 객체나 배열, 클래스의 인스턴스 변수는 **Runtime Data Area** 의 **Heap area**에 생성되며 Method area에 로드된 클래스만 객체로 생성이 가능하고 가비지 컬렉터가 이곳에서 참조되지 않는 메모리를 확인하고 제거한다.

메서드를 호출 할 때마다 생기는 로컬변수들은 **Runtime Data Area** 의 **Stack area**에 쌓이고 LIFO구조다. 이때의 로컬변수는 객체의 멤버변수를 제외한 나머지 변수들을 가리킨다.

# 생성자

- 기본 생성자
    - 파라미터가 없고 구현부는 비어있는 형태
    - 미 작성시 컴파일러가 자동 생성
    - 클래스이름(){}
- 파라미터 생성자
    - 기본생성자에 파라미터를 받는 형태
    - 주로 멤버변수의 초기화에 사용함
- this 와 this()
    - this는 객체를 참조하기 위한 용도로 로컬변수와 멤버변수의 이름이 동일할 때 이를 구분하기 위해서 사용함
    - 객체가 생성되어야 사용 가능하고 static 영역에서는 사용 불가
    - this()는 생성자를 호출하는데 사용함

    ```java
    //this() 활용 예시
    public class Hanghae {
    	String name;
    	int age; boolean isMan;

    	Hanghae(String name, int age, boolean isMan){
    					this.name = name;
    					this.age = age;
    					this.isMan = isMan;
    	}
    	Hanghae(String name, int age){
    					this(name, age, false);
    	}
    	Hanghae(String name){
    					this(name, 27, true);
    	}
    	Hanghae(){
    					this("최원빈", 100, true);
    	}
    }
    ```