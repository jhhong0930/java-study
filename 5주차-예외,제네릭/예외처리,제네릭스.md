# 예외처리

# 컴파일 에러, 런타임 에러

- 컴파일에러

소스코드(.java)에 대해 오타, 자료형 체크 등에 대한 기본적인 검사.

- 런타임에러
    - 에러
        - ex: OutOfMemoryError), StackOverFlowError. 즉 일단 발생하면 복구할 수 없는 심각한 오류.
        - 발생하면 프로그램이 비정상적으로 다운됨
    - 예외
        - 발생하더라도 프로그래머가 미리 작성한 코드로 대비가능

# 예외클래스 계층

- 두 그룹으로 나뉘어짐
    - RuntimeException의 자손들
        - 주로 프로그래머의 실수에 의해 발생.
        - ArrayIndexOutOfBoundsException, NullPointerException, ClassCastException  등
    - 그 외(IOException, ClassNotFoundException...)
        - 주로 외부(사용자들)에 의해 발생.
        - FileNotFoundException, ClassNotFoundException, DataFormatException

# thorw, 제네릭스 실전 in Spring

throw는 예외를 발생시키는 것

```java
public Product updateProduct(Long id, ProductMypriceRequestDto requestDto) {
    int myprice = requestDto.getMyprice();
    if (myprice < MIN_MY_PRICE) {
        **throw new IllegalArgumentException**("유효하지 않은 관심 가격입니다. 최소 " + MIN_MY_PRICE + " 원 이상으로 설정해 주세요.");
    }
```

---

다른 예

- 컨트롤러에서 예외발생

```java
@PostMapping("/auth/signup")
	public String signup(@Valid SignupDto signupDto, BindingResult bindingResult) {

		if(bindingResult.hasErrors()) {
			Map<String,String> errorMap = new HashMap<>();
			for(FieldError error: bindingResult.getFieldErrors()){
				errorMap.put(error.getField(), error.getDefaultMessage());
			}
		**	throw new CustomValidationException("유효성검사 실패함",errorMap);**
		}else {
			log.info(signupDto.toString());
			//SignupDto -> User
			User user = signupDto.toEntity();
			log.info(user.toString());
			User userEntity = authService.회원가입(user);
			System.out.print(userEntity);
			return "auth/signin";
		}
	}
```

- 사용자 정의 예외클래스

```java
public class CustomValidationException extends RuntimeException {
	
	private Map<String,String> errorMap;
	
	public CustomValidationException(String message, Map<String, String> errorMap) {
		super(message);// super(message)를 통해서 부모의 부모의...부모(Throwalbe.class)의 getMessage()함수에서 활용
		this.errorMap = errorMap;//반면 얘는 부모한테 넘길 게 아니라 여기서 자체적으로 Map타입의 에러를 리턴해야 하기때매 getter를 만듦
	}

	public Map<String,String> getErrorMap(){
		return errorMap;
	}
}
```

- 핸들러

```java
@RestControllerAdvice
public class RestApiExceptionHandler {

	@ExceptionHandler(CustomValidationException.class)//CustomValidationException이 발동하는 모든 익셉션을 이 함수가 가로채
	public CMRespDto<?> validationException(CustomValidationException e) {
		return new CMRespDto<Map<String,String>>(-1,e.getMessage(), e.getErrorMap());
	}
}
```

- 공통응답 DTO

```java
@AllArgsConstructor
@NoArgsConstructor
@Data
public class CustomRespDto<T> {
	private int code;//1(성공), -1(실패)
	private String message;
	private T data;  
}
```

- 결과

```java
{
"code": -1,
"message": "유효성검사 실패함",
"data":{
			"name": "공백일 수 없습니다",
			"email": "공백일 수 없습니다",
			"username": "크기가 2에서 20 사이여야 합니다"
			}
}
```

# 제네릭스

```java
class Box<T> {}
```

Box<T> : 지네릭 클래스. T의 Box, T Box라고 읽음

T : 타입변수 또는 타입매개변수(T는 타입문자)

Box: 원시타입(raw type)

### 특정 타입의 자손만 대입하도록 제한하기

```java
class FruitBox<T extends Fruit>{
	ArrayList<T> list = new ArrayList<T>;
...
}
```

```java
FruitBox<Apple> appleBox = new FruitBox<Apple>();
FruitBox<Toy> toyBox= new FruitBox<Toy>();
```

Apple과 Grape이 Fruit의 자손이기에 가능.

```java
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
fruitBox.add(new Apple()); //가능
fruitBox.add(new Grape()); //가능
```

### 와일드카드(?)

```java
classs Jucier{
	static Juice makeJuice(FruitBox<Fruit> box){
		//과일로 주스만드는 내용
	}
}
```

근데 이러면 makeJuice함수매개변수에 FruitBox<Fruit>밖에 못들어감. FruitBox<Apple>이런게 안된다. 게다가 제네릭타입이 다른것만으로는 오버로딩도 안됨

→해결:

```java
classs Jucier{
	static Juice makeJuice(FruitBox<? extendsFruit> box){
		//과일로 주스만드는 내용
	}
}
```

- 제네릭 메서드 만들기

```java
static <T extends Fruit> Juice makeJuice(FruitBox<T> box){
	//과일로 주스만드는 내용
}
```