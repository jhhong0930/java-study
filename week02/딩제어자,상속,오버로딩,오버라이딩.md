# 비전공자도 이해할 수 있는 비유로 보는 자바 ..

1. 상속, 오버라이딩, 오버로딩
2. 제어자

---------

















## 1. 항해로 보는 상속, 오버라이딩, 오버로딩

## 팀 스파르타가 돼보자!

















## 항해 1기 개시!

``` java
class 항해1기 {
    
    private List<String> 참여자;
	String 게더링크, 노션링크;
    
	public String 공지_기본_멘트(){
		return "항해 1기 여러분 안녕하십니까!"
    }
    
    public void 항해참여자(List<String> 참여자){
        this.참여자 = 참여자.clone();
    }   
}

//문제발생! 참여자가 한명씩 늘때도 리스트를 전부 바꿔줘야 한다!
```















## 해결은 어떻게?

``` java
// 인원이 추가될 때마다 리스트를 복제할 수는 없다! 
// 한명씩 들어올 때는 기존 리스트에 추가된 한명만 더해주자!
```













## 오버로딩 사용하기 딱 좋은 상황

``` java
class 항해1기 {
    
    private List<String> 참여자;
	private String 게더링크,노션링크;
	
    public String 공지_기본_멘트(){
		return "항해 1기 여러분 안녕하십니까!"
    }
    
    //참여자 리스트가 파라미터로 들어오면 이 메소드가 실행됩니다!
    public void 항해참여자(List<String> 참여자){
        this.참여자 = 참여자.clone();
    }
    
    //참여자 한명이 파라미터로 들어오면 이 메소드가 실행됩니다!
    public void 항해참여자(String 추가참여자){
       	this.참여자.add(추가참여자);
    }
}
// 이처럼 이름은 같지만 파라미터로 들어가는 인자의 수, 타입이 다른 메소드를 
// 같은 클래스 내에 정의하는 것을 `오버로딩`이라고 합니다!
```









------







## 99일 뒤









--------





## 항해 2기 개시 전 준비



``` java
// 2기 개시 전

// 이전 기수가 생겼다! 이전 기수의 정보를 사용할 수 있다.
// -> 이전 기수의 취업률을 2기 항해에 사용하자!
// -> 이전 기수의 주특기 선택 비율을 2기 항해에 사용하자!
// -> 나머지는 그냥 가져다 써도 될 것 같다!
```











## 상속하기 딱 좋은 상황

## 항해 2기 개시 !

``` java
// 기수가 지나면서 기능이 더해진 것을 알 수 있다!
class 항해2기 extends 항해1기 {
    private int 이전_기수_취업률;
    private int 이전_기수_주특기_선택비율;
}

//문제발생! 공지 멘트가 1기로 나온다!
```











## 해결은 어떻게?

``` java
//공지_기본_멘트의 리턴값을 바꿔줘야한다!
public String 공지_기본_멘트(){
		return "항해 1기 여러분 안녕하십니까!"
    }
```









## 오버라이딩 사용하기 딱 좋은 상황

```java
class 항해2기 extends 항해1기 {
    private int 이전_기수_취업률;
    private int 이전_기수_주특기_선택비율;
    
    //오버라이딩
    public String 공지_기본_멘트(){
		return "항해 2기 여러분 안녕하십니까!"
    }
}

//오버라이딩을 했기 때문에 공지_기본_멘트 메소드를 사용하면 
//자식 클래스인 항해2기의 공지_기본_멘트가 리턴된다!
```













------







## 99일 뒤









--------





## 항해 3기 개시 전 준비

``` java
// 3기 개시 전

// 두 번의 실수는 없다! 공지 텍스트 수정하자!
// 모든 기수의 누적 시간을 사용하자!
// 항해 전체 취업률도 추가하자!
// -> 나머지는 1,2 기에서 가져다 써도 될 것 같다!

```







## 자식이 부모가 되는 과정

## 항해 3기 개시!

``` java
class 항해3기 extends 항해2기 {
    private int 항해_	전체취업률;
    private int 항해_모든기수_누적_공부시간;    
    public String 공지_기본_멘트(){
		return "항해 3기 여러분 안녕하십니까!"
    }
 }

//부모클래스는 많은 자식 클래스를 가질 수 있습니다!
//하지만 자식은 여러 부모를 둘 수 없습니다.

//하지만 부모클래스의 자식클래스는 다른자식클래스의 부모클래스가 될 수 있습니다!
// -> 누군가의 부모는 누군가의 자식입니다...
           
//   (부모클래스   -   자식클래스)
//ex) 고조부모클래스 -> 조부모클래스 -> 부모클래스 -> 자식클래스
//                    (부모클래스   -  자식클래스) 
```









# 2. 제어자

1. 접근제어자
2. 흥선대원군















## 1. 접근제어자

![](https://images.velog.io/images/9sanha/post/6ee96126-8250-4ba9-8d29-57fa9d517a21/image.png)

접근 제어자는 4가지가 있습니다. 4가지를 하나씩 약간의 비유를 곁들여서 설명하겠습니다! 순서는 접근 제어가 심한 것에서 약한 것 순으로 설명하겠습니다.

![image-20211003211438959](C:\Users\9sanh\AppData\Roaming\Typora\typora-user-images\image-20211003211438959.png)

혈연의 관계만 접근할 수 있게 만들어주는 private이 그 첫번째입니다. 다른 클래스에서 사용할 수 없으며 무조건 같은 클래스 내의 메소드나 필드변수에서만 사용이 가능합니다.

다음은 private보다 제어가 느슨한 default입니다.

![](https://images.velog.io/images/9sanha/post/2c51e14f-d47f-46b0-b8c3-0f3d24e4e23c/image.png)

default는 같은 클래스에서만 쓸 수 있는 private와는 다르게, 다른 클래스라도 같은 패키지 안에만 있다면 접근할 수 있게 제어합니다.

그리고 이 default 보다 더 느슨한 접근 제어자가 있습니다.

그건 바로 protected인데,

![image-20211003211858484](C:\Users\9sanh\AppData\Roaming\Typora\typora-user-images\image-20211003211858484.png)

default에 private을 곁들인 느낌이죠? protected는 같은 패키지 내는 물론이고 다른 패키지지만 자식 클래스라면 사용할 수 있게 해줍니다!

![image-20211003212147760](C:\Users\9sanh\AppData\Roaming\Typora\typora-user-images\image-20211003212147760.png)

마지막으로 생성자에서 많이 봤던 public입니다! 같은 프로젝트 내라면 어디 패키지에 있든 다른 클래스를 상속했든간에 전부 사용할 수 있게 해줍니다.

## 2. 제어자 - 흥선 final

다음은 제어자계의 흥선대원군 final입니다.

![](https://images.velog.io/images/9sanha/post/dca9006a-1a95-4ec5-b7fe-9a79c91e3e74/image.png)

final의 성격은 서양을 배척했던 흥선대원군의 정신과 비슷합니다. 

이 특성을 살려서 상수, 메서드, 클래스에 사용된 final을 설명하겠습니다.

일단 흥선대원군의 class를 하나 만들겠습니다. 이 클래스에는 final로 선언된 String 흥선대원군의 마음이 있습니다.

![](https://images.velog.io/images/9sanha/post/356ec217-b88d-4206-b74e-49486a7818c7/image.png)

신하들이 말하듯 대원군의 마음은 상수이기 때문에 지지고 볶고 어떠한 말과 유혹을 다해도 바꿀 수 없습니다.

![](https://images.velog.io/images/9sanha/post/991414ab-fd3c-428e-b6dc-0cba3d7f4b2a/image.png)

이처럼 final은 상수 제어자입니다. 지금처럼 String 앞에 final이 붙으면 저 흥선대원군의 마음은 변할 수 없는 상수입니다.

따로 값을 초기화하는건 가능하지만, 한번 초기화된 상수는 값을 변경할 수 없습니다.

다음은 메소드에 final이 있을 때를 보겠습니다.

![](https://images.velog.io/images/9sanha/post/d53a8a3a-9e9b-4625-b163-78506b5b5193/image.png)

고종황제는 미국을 향한 아버지의 선포를 수습하고싶어합니다. 그 마음에 흥선대원군 클래스를 상속받아서 슬쩍 선포 내용을 바꾸려고 합니다.

아버지가 선포할 때마다 자신의 선포 내용이 나가게 하고싶어서 흥선의_선포 메소드를 오버라이딩 했습니다.

하지만 상대는 흥선대원군이죠.

![](https://images.velog.io/images/9sanha/post/132e4615-e60c-48f8-a6ec-1d21432903f8/image.png)

흥선의 선포 메소드 앞에 붙은 제어자 final 때문에 아무리 자식 클래스라도 오버라이딩할 수 없게 만들었습니다. 때문에 자식클래스인 고종클래스가 흥선의 선포를 오버라이딩 하지 못한것이죠.



흥선은 자신을 바꾸려고 하는 고종에게 화가났습니다.

![](https://images.velog.io/images/9sanha/post/9db6f2df-c101-4219-b781-90fc99427983/image.png)

그래서 자신의 클래스에 final을 선언해서 아무도 상속할 수 없게 만들어버렸습니다!

![](https://images.velog.io/images/9sanha/post/5246585f-8914-45fb-8576-2f4d925fbb9a/image.png)



여기까지입니다~!