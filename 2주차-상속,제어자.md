# 자바상속 특징

- 생성자와 초기화 블럭은 상속되지 않음. 멤버만 상속된다!
- 단일상속만 허용됨- 다중상속 허용시 서로 다른 부모클래스의 이름이 같은 메서드 구별 시 문제발생.
- 모든 클래스의 최상위 클래스는 Object클래스임. toString(), equals()와 같은 메서드 정의됨.

# 포함관계

- 상속을 통해 클래스를 재사용하는 방법이 있지만, 그 외의 방법도 존재함. 포함관계를 통해서 가능
    
    ex)
    
    ```jsx
    class Circle{
    	int x; //원점의 x좌표
    	int y; //원점의 y좌표
    	int r; //반지름
    }
    ```
    
    →아래처럼 간결하게 작성가능 & 재사용성 &관리수월
    
    ```jsx
    class Circle{
    	Point c = new Point();
    	int r;
    }
    ```
    

# is-a관계, has-a 관계

상속관계를 맺을지, 포함관계를 맺을지 혼돈 가능

```jsx
//포함관계 
class Circle{
		Point c = new Point();
		int r;
}
 ================================
//상속관계
class Circle extends Point{
		int r;
}
```

뭘 사용할지 모르겠다면, 다음 중 더 말이 되는 것을 선택

- Circle is a Point
- Cirlce has a Point

→has a가 더 자연스러우므로 포함관계를 맺어준다

# 오버라이딩

조상클래스로부터 상속받은 메서드의 내용을 변경하는 것

조건:

1. 이름이 같아야 함
2. 매개변수가 같아야 함
3. 반환타입이 같아야 함

추가조건:

1. 접근제어자를 조상클래스의 메서드보다 좁은범위로 변경불가
    
    조상의 메서드가 protected라면, 오버라이딩한 자손 메서드는 protected나 public이어야 함.
    
    참고:public-protected-default-private 순임.
    
2. 예외는 조상클래스의 메서드보다 많이 선언 불가.
    
    ```jsx
    class Parent{
    		void parentMethod() throws IOException, SQLException{
    =============================
    class Child extends Parent{
    		void parentMethod() throws IOException{  //올바르게 오버라이딩됨
    ```
    
    단, 그냥 Exception은 모든 예외의 최고조상이므로 가장 많은 개수의 예외를 던지게 선언된것이므로 주의.
    

# 오버로딩과 오버라이딩

- 오버로딩: 이름만 같고, 클래스내에서 걍 새로운 메소드를 추가하는 것
- 오버라이딩: 조상으로부터 상속받은 메서드 내용 변경하는 것

# super

조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고는 super와 this는 근본적으로 같음.

```java
class Test{
	public static void main(String args[]){
		Child c = new Child();
		c.method();
	}
}

class Parent{
	int x = 10;
}

class Child extends Parent{
	int x = 20;
	void method(){
		System.out.println("x="+x);
		System.out.println("this.x="+this.x); 
		System.out.println("super.x="+super.x); 
```

- Q: 차례대로 뭐가 출력될까?
    
    20, 20, 10
    
    - 그렇다면 Child에서 int x가 정의되지 않았다면?
        
        10,10,10
        

# super()

핵심개념: 자손클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 **모두 합쳐진 하나의 인스턴스**가 생성된다. 고로, 자손클래스의 멤버가 조상클래스의 멤버도 사용할수 있어야 하므로 조상의 멤버들이 먼저 초기화되어야 한다.

- 자손클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성됨. 그래야 자손클래스의 인스턴스가 조상클래스의 멤버를 사용할 수 있음. 이때 최고 클래스인 Object클래스의 생성자인 object()까지 가야 끝이 남.
- 또한, 모든 생성자(objec()제외)는 **첫줄**에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야 함. 직접 안하면 컴파일러가 생성자 첫줄에 super()를 자동으로 추가해줌
이유: 자손클래스의 멤버가 조상클래스의 멤버를 사용할 수도 있으므로, 조상의 멤버들이 먼저 초기화가 되어야 하기 때문임

아래 예제를 실행하면 컴파일 에러발생함.

```jsx
class PointTest{
		public static void main(String args[]){
			Point3D p3 = new Point3D(1,2,3);
		}
}

class Point{
		int x,y;
		Point (int x, int y){
			this.x = x;
			this.y = y;
		}
		
		String getLocation(){
			return "dfsdf"
		}
}

class Point3D extends Point{
		int z;
		
		Point3D(int x, int y, int z){
			this.x = x;
			this.y = y;
			this.z = z;
		}
		String getLocation(){
			return "dsfasdfsdfasf"
		}
}
	
```

Point3D클래스의 생성자의 첫줄이 생성자가 아니니까, 자동으로 super()를 넣어주는데, 이 super()는 곧 조상의 기본생성자인 Point()를 뜻하므로 Point()를 호출하려 할때, Point클래스에 기본생성자가 없으므로 에러가 발생되는 것임.(클래스에 다른 생성자가 있다면 기본생성자는 자동으로 생기지 않음).

고로 (Point클래스의 생성자에도 기본생성자(Point())를 따로 추가  &&  Poinst3D함수에 super()추가)하거나, 생성자 Point3D(int x, int y, int z)의 첫줄에 Point(int x, int y)를 호출하도록 super(x, y)를 추가해주면 된다! 

→조상클래스의 멤버변수를 생성자에 의해 초기화되도록 함

```java
Point3D(int x, int y, int z){
		super(x,y)
		this.z = z;
}
```

why? 자손클래스의 멤버가 조상클래스의 멤버를 사용할 수도 있기 때문!

---------------

# 제어자 종류

- 접근제어자
    - public, protected,default, private
- 그외
    - static, final, abstract, native, transient, synchronized, volatile, strictfp

# final

- 변수에 사용시: 값을 변경할 수 없는 상수가 됨
- 메서드에 사용시: 오버라이딩 할 수 없게 됨
- 클래스에 사용시: 자신을 확장하는 자손클래스를 정의하 못하게 함. 즉 다른 클래스의 조상이 될 수 없음

# 생성자를 이용한 final 멤버변수의 초기화

final변수는 상수이므로 보통 선언과 초기화를 동시에 하지만, 인스턴스변수의 경우 생성자에서 초기화를 할 수 있음. 이렇게 하면 각 인스턴스마다 final이 붙은 멤버변수가 다른 값을 갖도록 하는 것이 가능해짐.

```jsx
class Card{
	final int NUMBER;
	final String KIND; //상수지만 선언할때 바로 초기화하지 않고 생성자에서 초기화.
	static int width = 100;
	static int height = 250;

	Card(String kind, int num){
		KIND = kind;
		NUMBER = num;
	}
}
```

# 접근제어자

- private
    
    같은 클래스 내애서만 접근가능
    
- default
    
    같은 패키지 내에서만 접근가능
    
- protected
    
    같은 패키지내에서, 그리고 다른 패키지에서도 되긴 하지만, 이땐 오직 자손클래스만 접근가능
    
- public
    
    다 가능
    

- 생성자의 접근제어자- **싱글톤 패턴**

생성자가 private이기에 생성자를 통해 직접 인스턴스 생성불가.(대신 public 메서드를 통해 인스턴스 접근).

→ 인스턴스를 하나만 메모리에 띄우고 그것만 사용할 수 있게 인스턴스 개수 제한 가능

```jsx
final class SingleTon{// 상속못하므로 final붙여서 알려주는 게 좋음.안붙여도 상관없긴함
	private static Singleton s = new Singleton(); //getinstance()메서드에서 사용될수 있도록 인스턴스 미리 생성되어야 하므로 static임
	
	private Singleton(){
	//생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없음.
	//자손클래스는 인스턴스 생성할때 조상클래스의 생성자 호출해야만 하는데, private이면 호출불가하므로.
		....
	}
	public static Singleton getInstance(){
		return s;
	}
}
```
